Анализ сложности алгоритмов.

1. main.py

1. **Приведение к нижнему регистру**:
   - `cleaned_word = word.lower()`
   - Сложность: O(n), где n — длина строки `word`, так как нужно пройтись по каждому символу строки.

2. **Удаление пробелов и специальных символов**:
   - `cleaned_word = ''.join(char for char in cleaned_word if char.isalnum())`
   - Здесь мы проходим по каждому символу строки `cleaned_word` (которая, в худшем случае, равна длине `word`),
   и проверяем, является ли символ алфавитно-цифровым. Это также имеет сложность O(n).

3. **Сравнение строки с её реверсом**:
   - `cleaned_word == cleaned_word[::-1]`
   - Для создания реверса строки также требуется O(n), и затем еще одно сравнение двух строк,
   что также будет O(n) в худшем случае.

Теперь суммируем все части:
- Приведение к нижнему регистру: O(n)
- Удаление пробелов и специальных символов: O(n)
- Сравнение с реверсом: O(n)

В итоге общая сложность функции `is_palindrome` составляет:
\[ O(n) + O(n) + O(n) = O(n) \]

Таким образом, сложность алгоритма по Big O — **O(n)**, где n — это длина входной строки.

O(n): Линейная сложность. Время выполнения алгоритма пропорционально размеру входных данных.
Например, просмотр всех элементов в массиве.


2. hw_stack.py


1. **Инициализация стека**:
   ```python
   def __init__(self):
       self.items = []
   ```
   - Сложность: O(1). Инициализация списка не зависит от размера входных данных.

2. **Проверка на пустоту**:
   ```python
   def is_empty(self):
       return self.items == []
   ```
   - Сложность: O(1). Проверка на пустоту выполняется за постоянное время.

3. **Добавление элемента в стек** (метод `push`):
   ```python
   def push(self, item):
       self.items.append(item)
   ```
   - Сложность: O(1) в среднем. Метод `append` добавляет элемент в конец списка,
   что в большинстве случаев выполняется за постоянное время. Однако в некоторых случаях,
   когда список нужно увеличить, сложность может быть O(n), но это происходит редко.

4. **Удаление элемента из стека** (метод `pop`):
   ```python
   def pop(self):
       return self.items.pop()
   ```
   - Сложность: O(1). Удаление последнего элемента из списка также выполняется за постоянное время.

5. **Получение верхнего элемента стека** (метод `peek`):
   ```python
   def peek(self):
       return self.items[-1]
   ```
   - Сложность: O(1). Доступ к последнему элементу списка также выполняется за постоянное время.

6. **Вывод содержимого стека**:
   ```python
   for item in reversed(stack.items):
       print(item)
   ```
   - Сложность: O(n), где n — количество элементов в стеке. Метод `reversed` создает итератор,
   который проходит по всем элементам стека.

Теперь суммируем сложности:

- Инициализация: O(1)
- Проверка на пустоту: O(1)
- Добавление элемента: O(1) (в среднем)
- Удаление элемента: O(1)
- Получение верхнего элемента: O(1)
- Вывод всех элементов: O(n)

Таким образом, для операций, связанных с добавлением, удалением и получением элемента,
сложность составляет **O(1)** в среднем, а для вывода всех элементов — **O(n)**.

Итак, общая оценка сложности:
- Наиболее значимой о перацией в контексте использования стека является вывод содержимого, который имеет сложность O(n).
Однако, для основных операций стека (push, pop, peek), сложность составляет O(1).


3. hw_queue.py

1. **Инициализация очереди**:
   ```python
   def __init__(self):
       self.items = []
   ```
   - Сложность: O(1). Инициализация списка не зависит от размера входных данных.

2. **Проверка на пустоту**:
   ```python
   def is_empty(self):
       return self.items == []
   ```
   - Сложность: O(1). Проверка на пустоту выполняется за постоянное время.

3. **Добавление элемента в очередь** (метод `enqueue`):
   ```python
   def enqueue(self, item):
       self.items.insert(0, item)
   ```
   - Сложность: O(n). Метод `insert(0, item)` добавляет элемент в начало списка,
   что требует смещения всех остальных элементов на одну позицию, и это занимает линейное время.

4. **Удаление элемента из очереди** (метод `dequeue`):
   ```python
   def dequeue(self):
       return self.items.pop()
   ```
   - Сложность: O(1). Удаление последнего элемента из списка выполняется за постоянное время.

5. **Получение размера очереди** (метод `size`):
   ```python
   def size(self):
       return len(self.items)
   ```
   - Сложность: O(1). Получение длины списка выполняется за постоянное время.

6. **Вывод содержимого очереди**:
   ```python
   for task in reversed(queue.items):
       print(task)
   ```
   - Сложность: O(n). Метод `reversed` создает итератор, который проходит по всем элементам очереди,
    это занимает линейное время.

Теперь суммируем сложности:

- Инициализация: O(1)
- Проверка на пустоту: O(1)
- Добавление элемента: O(n) (из-за `insert`)
- Удаление элемента: O(1)
- Получение размера: O(1)
- Вывод всех элементов: O(n)

Таким образом, для операций, связанных с добавлением элемента, сложность составляет **O(n)**,
а для удаления, проверки на пустоту и получения размера — **O(1)**.
Вывод всех элементов также имеет сложность **O(n)**.

Итак, общая оценка сложности:
- Основной проблемой в данном коде является метод добавления (enqueue), который имеет с ложность **O(n)**.
Это делает очередь менее эффективной, особенно при большом количестве операций добавления.
O(n): Линейная сложность. Время выполнения алгоритма пропорционально размеру входных данных.
Например, просмотр всех элементов в массиве.
Для реализации очереди обычно используют двусвязный список или очередь с использованием `collections.deque`,
которая имеет сложность O(1) для обеих операций (enqueue и dequeue).

4. hw_sorted.py

### 1. Функция `min_sort`

```python
def min_sort(arr):
   # Проходим по всему списку
   for i in range(len(arr)):
       # Предполагаем, что первый элемент в неотсортированной части - это минимальный
       min_index = i
       # Ищем минимальный элемент в оставшейся части списка
       for j in range(i+1, len(arr)):
           if arr[j] < arr[min_index]:
               min_index = j
       # Меняем местами найденный минимальный элемент с первым элементом в неотсортированной части
       arr[i], arr[min_index] = arr[min_index], arr[i]
```

- Внешний цикл (`for i in range(len(arr))`) выполняется `n` раз, где `n` — длина массива.
- Внутренний цикл (`for j in range(i+1, len(arr))`) выполняется в среднем `(n-i)` раз для каждого `i`.
Таким образом, общее количество итераций внутреннего цикла будет суммировать от `n-1` до `0`, то есть:

  \[
  (n-1) + (n-2) + ... + 1 + 0 = \frac{n(n-1)}{2} \approx \frac{n^2}{2}
  \]

- Сложность функции `min_sort` составляет **O(n²)**.

### 2. Функция `max_sort`

```python
def max_sort(arr):
   # Проходим по всему списку
   for i in range(len(arr)):
       # Предполагаем, что первый элемент в неотсортированной части - это максимальный
       max_index = i
       # Ищем максимальный элемент в оставшейся части списка
       for j in range(i+1, len(arr)):
           if arr[j] > arr[max_index]:
               max_index = j
       # Меняем местами найденный максимальный элемент с первым элементом в неотсортированной части
       arr[i], arr[max_index] = arr[max_index], arr[i]
```

- Аналогично функции `min_sort`, внешний цикл также выполняется `n` раз.
- Внутренний цикл снова выполняется `(n-i)` раз в среднем, что приводит к аналогичному количеству итераций,
как и в предыдущем анализе.

- Сложность функции `max_sort` также составляет **O(n²)**.

### Заключение

Обе функции имеют временную сложность **O(n²)** из-за вложенных циклов,
где внешний цикл проходит по всем элементам массива, а внутренний цикл ищет минимальный или максимальный элемент
в оставшейся части массива.

### Общая сложность программы

- Ввод чисел и обработка ошибок: **O(m)**, где `m` — количество введенных чисел.
- Сортировка: **O(n²)** для `min_sort` или `max_sort`.

Таким образом, если считать `n` как длину массива `numbers`, общая сложность программы будет **O(n²)** для сортировки,
что является основной затратой времени.
O(n^2): Квадратичная сложность. Время выполнения алгоритма зависит от квадрата размера входных данных.
